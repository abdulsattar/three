<html>
	<head>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="three.js"></script>
		<script src="obj-loader.js"></script>
		<script src="orbit-controls.js"></script>
    <script src="fxaa-shader.js"></script>
    <script src="mesh-line.js"></script>
		<script>

      const parameters = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        stencilBuffer: false,
      };

      window.target = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, parameters);
      target.depthTexture = new THREE.DepthTexture();
      target.depthTexture.type = THREE.UnsignedShortType;
      function addLights(scene) {
        const x = new THREE.Vector3(1, 0, 0);
        const nx = new THREE.Vector3(-1, 0, 0);
        const y = new THREE.Vector3(0, 1, 0);
        const ny = new THREE.Vector3(0, -1, 0);
        const z = new THREE.Vector3(0, 0, 1);
        const nz = new THREE.Vector3(0, 0, -1);
        const positions = [x, nx, y, ny, z, nz];
        positions.forEach((position) => {
          const light = new THREE.DirectionalLight(0xffffff, 1);
          light.position.copy(position.multiplyScalar(1));
          scene.add(light);
        });
      }

      function addEdges(mesh, scene) {
        if (!(mesh instanceof THREE.Mesh)) return;
        const edges = new THREE.EdgesGeometry(mesh.geometry, 15);
        const line = new THREE.LineSegments(
          edges,
          new THREE.ShaderMaterial({
            defines: {},
            uniforms: { 
              tDepth: { value: window.depthTexture },
              cameraNear: { value: camera.near },
              cameraFar: { value: camera.far },
            },
            vertexShader: `
              varying vec2 vUv;

              void main() {
               vUv = uv;
               gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
              }
            `,
            fragmentShader: `
              #include <packing>
              varying vec2 vUv;
              uniform sampler2D tDepth;
              uniform float cameraNear;
              uniform float cameraFar;

              float readDepth (sampler2D depthSampler, vec2 coord) {
                float fragCoordZ = texture2D(depthSampler, coord).x;
                float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
                return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );
              }
            
              void main() {
                float oldDepth = texture2D(tDepth, vUv).r;
                if (oldDepth >= gl_FragCoord.z) {
                  discard;
                  return;
                }
                gl_FragColor = vec4(1, 0, 0, 1);
              }
            `,
          }));
        scene.add(line);
      }

      var scene = new THREE.Scene();
      window.camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
      camera.position.copy(new THREE.Vector3(12, 11, -11));
      camera.position.z = 1.5;
      controls = new OrbitControls(camera);
      // scene.add(new THREE.AmbientLight(0xffffff));
      addLights(scene);

      var renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.autoClear = false;
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild(renderer.domElement);

      var loader = new THREE.OBJLoader();
      var edgesScene = new THREE.Scene();
      loader.load('c20.obj', (object) => {
        object.traverse(mesh => { 
          // mesh.material = new THREE.MeshPhongMaterial({ color: 0XD3D3D3 });
          mesh.material = new THREE.ShaderMaterial({
            defines: {},
            uniforms: {},
            vertexShader: THREE.FXAAShader.vertexShader,
            fragmentShader: `
              varying vec2 vUv;
            
              void main() {
                float d = gl_PointCoord.y;
                gl_FragColor = vec4(d, d, d, d);
              }
            `,
          });
          addEdges(mesh, edgesScene);
        });
        scene.add(object);

        const frameCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const frameScene = new THREE.Scene();
        const quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2));
        quad.frustumCulled = false; // Avoid getting clipped
        const frameMaterial = new THREE.ShaderMaterial({
          defines: {},
          uniforms: { 
            tDiffuse: { value: target.texture },
            tDepth: { value: target.depthTexture },
            resolution: { value: new THREE.Vector2( 1 / 1024, 1 / 512 ) }
          },
          vertexShader: THREE.FXAAShader.vertexShader,
          fragmentShader: `
            varying vec2 vUv;
            uniform sampler2D tDiffuse;
          
            void main() {
              gl_FragColor = texture2D(tDiffuse, vUv);
            }
          `,
        });
        quad.material = frameMaterial;
        frameScene.add(quad);

        var animate = function () {
          requestAnimationFrame(animate);

          renderer.clearTarget(target, true, true, true);
          renderer.clear(true, true, true);
          renderer.render(scene, camera);
          // window.depthTexture = target.depthTexture;
          // target.depthTexture = null;
          // renderer.render(frameScene, frameCamera);
          // renderer.clearDepth();
          // renderer.render(edgesScene, camera);
        };
        animate();
      });

		</script>
	</body>
</html>